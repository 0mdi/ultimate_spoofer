#include "pattern_scanner.hpp"

PatternScanner scanner;

void PatternScanner::set_region(uintptr_t start, size_t size)
{
	m_start = start;
	m_size = size;
}

void PatternScanner::str_to_bin(const char* str_pattern, uint8_t* bin, size_t* outlen)
{
	size_t pattern_ofs = 0;

	auto testlen = strlen(str_pattern);

	int cntr = 0;
	while (cntr < testlen)
	{
		while (str_pattern[cntr] == ' ')
		{
			cntr++;
		}

		bool has_whitespace = false;
		while (str_pattern[cntr] == '?')
		{
			cntr++;
			has_whitespace = true;
		}

		if (has_whitespace)
		{
			bin[pattern_ofs++] = 0;
		}
		else
		{
			auto byte = hex_to_bin(&str_pattern[cntr]);
			bin[pattern_ofs++] = byte;
			cntr += 2;
		}
	}

	*outlen = pattern_ofs;
}
uintptr_t PatternScanner::find_call(const char* pattern)
{
	uint8_t binary[200];

	size_t out_len = 0;

	str_to_bin(pattern, &binary[0], &out_len);

	return find_call_code(&binary[0], out_len);
}
uintptr_t PatternScanner::find_call_code(const uint8_t* binary, size_t len)
{
	auto memory = find_memory_code(binary, len);
	if (memory)
	{
		auto offset = *(INT32*)(memory + 1);

		return memory + 5 + offset;
	}
	return 0;
}
uintptr_t PatternScanner::find_offset(const char* pattern, size_t pos)
{
	uint8_t binary[200];

	size_t out_len = 0;

	str_to_bin(pattern, &binary[0], &out_len);

	return find_offset_code(&binary[0], out_len, pos);
}
uintptr_t PatternScanner::find_offset_code(const uint8_t* binary, size_t len, size_t pos)
{
	auto memory = find_memory_code(binary, len);
	if (memory)
	{
		auto offset = *(INT32*)(memory + pos);

		return memory + 7 + offset;
	}
	return 0;
}
uintptr_t PatternScanner::find_memory(const char* pattern)
{
	uint8_t binary[200];

	size_t out_len = 0;

	str_to_bin(pattern, &binary[0], &out_len);
	return find_memory_code(&binary[0], out_len);
}
uintptr_t PatternScanner::find_memory_code(const uint8_t* binary, size_t len)
{
	size_t bin_len = len;
	auto memory = (const uint8_t*)(m_start);

	for (size_t cur_offset = 0; cur_offset < (m_size - bin_len); cur_offset++)
	{
		auto has_match = true;

		for (size_t pos_offset = 0; pos_offset < bin_len; pos_offset++)
		{
			if (binary[pos_offset] != 0 && memory[cur_offset + pos_offset] != binary[pos_offset])
			{
				has_match = false;
				break;
			}
		}

		if (has_match)
		{
			return m_start + cur_offset;
		}
	}

	return 0;
}
uint8_t PatternScanner::hex_to_bin(const char* str)
{
	uint8_t  pos;
	uint8_t  idx0;
	uint8_t  idx1;

	// mapping of ASCII characters to hex values
	const uint8_t hashmap[] =
	{
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // ........
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // ........
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // ........
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // ........
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, //  !"#$%&'
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // ()*+,-./
		0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, // 01234567
		0x08, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 89:;<=>?
		0x00, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x00, // @ABCDEFG
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // HIJKLMNO
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // PQRSTUVW
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // XYZ[\]^_
		0x00, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x00, // `abcdefg
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // hijklmno
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // pqrstuvw
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // xyz{|}~.
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // ........
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // ........
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // ........
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // ........
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // ........
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // ........
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // ........
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // ........
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // ........
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // ........
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // ........
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // ........
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // ........
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // ........
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // ........
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00  // ........
	};

	idx0 = (uint8_t)str[0];
	idx1 = (uint8_t)str[1];

	return (uint8_t)(hashmap[idx0] << 4) | hashmap[idx1];
}